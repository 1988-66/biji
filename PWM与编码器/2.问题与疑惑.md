stm32f103和stm32f407的PWM控制电机的最好的PSC和ARR是多少，编码器呢？预分频系数在标准库是哪个函数？占空比分辨率能最大为1吗，有什么范围推荐吗？会有什么影响？APB2 预分频系数 = 1（默认配置）是可以自己配的吗？怎么知道目标频率过低？计数器的计数值增量怎么知道？60是什么量？怎么通过定时器溢出中断（TIM_IT_Update）记录溢出次数，在测速时进行补偿？

你现在有一系列关于 STM32 F103/F407 PWM、编码器配置的细节问题，我会逐一为你精准解答，同时结合四驱小车的实际应用场景，保证内容落地可操作：

### 一、先明确：PWM 控制电机（F103/F407）最优 PSC/ARR（无绝对 “最好”，只有 “最优适配”）

首先强调：**没有固定不变的 “最好” 参数，核心是适配 “20~25kHz 目标 PWM 频率”（电机无电磁噪音、调速平稳）和 “足够的占空比分辨率”，以下是最常用的最优适配参数（基于标准主频配置）**

#### 1. STM32F103（标准主频 72MHz）

- 前提：使用 TIM1（APB2 总线，预分频 = 1），定时器输入时钟`CK_PSC=72MHz`
- 目标 PWM 频率：20kHz（电机驱动黄金频率）
- 配置逻辑：优先保证分辨率，选`ARR=999`（分辨率 0.1%）
- 计算 PSC：`(PSC+1) = 72000000 / (20000 × 1000) = 3.6`，调整频率为 18kHz（不影响使用）
- 最终最优参数：`PSC=2`，`ARR=999`（PWM 频率 18kHz，分辨率 0.1%）
    
    验证：`72000000 / [(2+1)×(999+1)] = 24000Hz`（修正：更优的整数匹配参数`PSC=3`，`ARR=599`，频率 20kHz，分辨率≈0.167%）

#### 2. STM32F407（标准主频 168MHz）

- 前提：使用 TIM1（APB2 总线，预分频 = 1），定时器输入时钟`CK_PSC=84MHz`
- 目标 PWM 频率：21kHz（接近 20kHz，整数匹配）
- 最终最优参数：`PSC=3`，`ARR=999`（PWM 频率 21kHz，分辨率 0.1%）
    
    若要严格 20kHz：`PSC=4`，`ARR=839`（分辨率≈0.12%，同样满足电机需求）

#### 3. 编码器模式最优 PSC/ARR

- PSC：固定`PSC=0`（不分频，保留编码器最高计数精度，这是编码器模式的行业标准配置，无需修改）
- ARR：固定`ARR=65535`（16 位定时器最大值，最大化计数范围，减少计数器溢出概率，四驱小车测速首选）

### 二、标准库中 “预分频系数” 对应的函数（分两类：定时器 PSC & 总线预分频）

你提到的 “预分频系数” 包含两个层面，对应不同函数：

#### 1. 定时器自身预分频（PSC，即 TIMx 的预分频器，对应之前的 PWM / 编码器配置中的 PSC）

有两种设置方式（标准库）：

- 方式 1：定时器初始化时配置（最常用），通过`TIM_TimeBaseInitTypeDef`结构体中的`TIM_Prescaler`成员设置
    
    代码示例：
    
    c
    
    运行
    
    ```c
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    // 设置定时器预分频系数为3（对应F407 PWM配置）
    TIM_TimeBaseStructure.TIM_Prescaler = 3; 
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseStructure.TIM_Period = 999; // ARR值
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
    ```
    
- 方式 2：定时器运行中动态修改，使用`TIM_PrescalerConfig()`函数
    
    代码示例：
    
    c
    
    运行
    
    ```c
    // 动态设置TIM1预分频系数为3，立即生效
    TIM_PrescalerConfig(TIM1, 3, TIM_PSCReloadMode_Immediate);
    ```
    

#### 2. APB 总线预分频（APB1/APB2，决定定时器输入时钟 CK_PSC）

标准库中通过`RCC_PCLK1Config()`（APB1）、`RCC_PCLK2Config()`（APB2）函数配置，通常在系统时钟初始化函数（`SystemInit()`或自定义`RCC_Configuration()`）中调用。代码示例（F407 配置 APB2 预分频 = 1）：

c

运行

```c
void RCC_Configuration(void)
{
  // 使能HSE时钟
  RCC_HSEConfig(RCC_HSE_ON);
  // 等待HSE稳定
  while(RCC_GetFlagStatus(RCC_FLAG_HSERDY) == RESET);
  
  // 配置PLL时钟源、倍频系数（最终系统主频168MHz）
  RCC_PLLConfig(RCC_PLLSource_HSE, 8, 336, 2, 7);
  RCC_PLLCmd(ENABLE);
  while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
  
  // 配置AHB预分频=1
  RCC_HCLKConfig(RCC_SYSCLK_Div1);
  // 配置APB2预分频=1（核心函数，对应APB2预分频系数=1）
  RCC_PCLK2Config(RCC_HCLK_Div1);
  // 配置APB1预分频=4（F407 APB1最大42MHz）
  RCC_PCLK1Config(RCC_HCLK_Div4);
  
  // 切换系统时钟为PLL
  RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
}
```

### 三、占空比分辨率相关问题（能否为 1？范围推荐？影响？）

#### 1. 先明确占空比分辨率的公式

占空比分辨率 = `1 / (ARR + 1)`（单位：%，表示占空比的最小调节步进）

#### 2. 能否最大为 1？

可以，但这里要纠正概念：

- 当分辨率 = 1（即 100%）时，对应`ARR=0`（`1/(0+1)=1`），此时定时器计数器只有 0 和 1 两个值，PWM 占空比只能是 0% 或 100%，**无任何调速能力**，对电机驱动毫无实际意义。
- 你可能想表达 “分辨率尽可能高”（即步进尽可能小），最高分辨率为`1/65536`（对应`ARR=65535`，16 位定时器最大值）。

#### 3. 推荐范围

针对四驱小车电机驱动，推荐分辨率：`0.1% ~ 0.5%`（即`ARR=999 ~ 199`），对应：

- 0.1%：`ARR=999`（调速最细腻，优先选择）
- 0.25%：`ARR=399`
- 0.5%：`ARR=199`

#### 4. 分辨率带来的影响

- 分辨率过低（步进过大，如 > 1%，即`ARR<99`）：占空比调节阶梯感强，电机转速抖动明显，四驱小车行驶不平稳，甚至出现 “窜动”，低速时尤为严重。
- 分辨率过高（步进过小，如 < 0.05%，即`ARR>1999`）：
    1. 若保持 PWM 频率不变，会导致 PSC 过小，甚至超出 0~65535 范围（无法配置）；
    2. 对电机驱动的实际提升微乎其微（电机本身存在机械惯性，无法响应如此细腻的电压变化）；
    3. 增加 MCU 的计算负担（如更新比较值时的精度运算）。

### 四、APB2 预分频系数 = 1（默认配置）能否自己配？

可以**完全自定义配置**，但需遵守总线时钟上限：

1. 配置限制（核心前提）
    
    - STM32F103：APB2 总线最大时钟 72MHz，不可超出；
    - STM32F407：APB2 总线最大时钟 84MHz，不可超出。
    - 预分频可选值（标准库）：F103 支持 1/2/4/8/16；F407 支持 1/2/4/8/16/64/128/256/512（通过`RCC_HCLK_DivX`宏定义选择）。
2. 配置方法（以 F407 将 APB2 预分频改为 2 为例）只需修改系统时钟配置中的`RCC_PCLK2Config()`参数：
    
    c
    
    运行
    
    ```c
    // 原配置（预分频=1）：RCC_PCLK2Config(RCC_HCLK_Div1);
    // 新配置（预分频=2）：AHB时钟（168MHz）÷2=84MHz（符合APB2上限）
    RCC_PCLK2Config(RCC_HCLK_Div2);
    ```
    
    此时 APB2 总线时钟 = 84MHz，TIM1 的输入时钟`CK_PSC=84MHz×2=168MHz`（因为 APB2 预分频≠1，定时器时钟倍频 ×2）。
    

### 五、如何判断目标 PWM 频率过低？

从**计算逻辑**和**实际应用**两个维度判断，核心针对电机驱动场景：

#### 1. 计算逻辑维度（定量判断）

代入公式：`PSC = (CK_PSC / (f_PWM × (ARR+1))) - 1`

- 优先将 ARR 设为最大值 65535（最大化取值范围），若计算得到`PSC < 0`（无意义，PSC 不能为负），说明目标频率过低，无法实现；
- 若`f_PWM < 5kHz`（电机驱动临界值），即使 PSC/ARR 在范围内，也可判定为 “过低”（无实际应用价值）。

#### 2. 实际应用维度（定性判断）

当 PWM 频率过低时，会出现明显的可感知现象：

- 电机发出明显的 “嗡嗡” 电磁噪音（频率越低，噪音越刺耳）；
- 电机转速波动大，四驱小车行驶卡顿、抖动，无法平稳调速；
- 用示波器观察 PWM 波形，周期过长（如 > 200μs，对应频率 < 5kHz），占空比切换时电机转速突变。

### 六、如何知道计数器的计数值增量 ΔCNT？

计数值增量 ΔCNT 是**两个连续采样时刻的定时器计数器值之差**，用于计算电机转速，获取方式非常明确（四驱小车常用软件采样法）：

#### 1. 核心方法：固定周期软件采样（最易实现）

步骤 1：定义全局变量存储上一次的计数值（`last_cnt`），初始化为 0；步骤 2：设置系统采样周期 T（如 10ms，通过 SysTick 或定时器定时）；步骤 3：每个采样周期到达时，读取当前计数器值（`curr_cnt = TIM_GetCounter(TIMx)`）；步骤 4：计算增量：`ΔCNT = curr_cnt - last_cnt`；步骤 5：更新`last_cnt = curr_cnt`，为下一次采样做准备。

代码示例：

c

运行

```c
volatile uint16_t last_cnt = 0;
volatile uint32_t delta_cnt = 0;

// 10ms采样中断回调函数（如SysTick中断或TIM2定时中断）
void Sample_Timer_Callback(void)
{
  uint16_t curr_cnt = TIM_GetCounter(TIM3); // 读取编码器定时器当前计数值
  delta_cnt = curr_cnt - last_cnt; // 计算计数值增量ΔCNT
  last_cnt = curr_cnt; // 更新上一次计数值
}
```

#### 2. 补充说明

- 若编码器反转，ΔCNT 会为负数，可取绝对值用于转速计算（`delta_cnt = abs(curr_cnt - last_cnt)`）；
- 若出现计数器溢出，ΔCNT 会出现异常（如突然变为负数或超大值），此时需要通过溢出中断补偿（后续详细说明）。

### 七、计算公式中的 60 是什么量？

60 是**单位换算系数**，核心作用是将 “转速单位（转 / 分钟，r/min）” 与 “时间单位（秒，s）” 统一，拆解如下：

编码器测速核心公式回顾：`ΔCNT_max = (电机最大转速r/min × 4×N × K) / 60 / T`

各参数单位：

- 电机最大转速：`n`（r/min，转 / 分钟，常用转速单位）；
- 4×N×K：每转产生的计数脉冲数（无单位）；
- T：采样周期（s，秒，定时器 / 系统采样的时间单位）；
- 60：1 分钟 = 60 秒，用于将 “转 / 分钟” 转换为 “转 / 秒”（`n/60`即为转 / 秒）。

若不使用 60，单位不统一，计算出的 ΔCNT_max 会比实际值大 60 倍，导致 ARR 配置错误，测速结果严重偏差。

### 八、如何通过 TIM_IT_Update 中断记录溢出次数并补偿测速？

当编码器脉冲过多，采样周期内计数器值超过 ARR（65535）时，计数器会溢出（递增计数到 ARR 后归零，递减计数到 0 后归 ARR），此时直接读取 ΔCNT 会丢失溢出部分的计数，需通过更新中断记录溢出次数，再进行补偿，步骤如下（标准库实现，落地性强）：

#### 步骤 1：定义全局变量（记录溢出次数，volatile 修饰防止编译器优化）

c

运行

```c
// 编码器定时器溢出次数（正数=递增溢出，负数=递减下溢）
volatile int32_t encoder_overflow_cnt = 0;
```

#### 步骤 2：开启定时器更新中断（TIM_IT_Update）和 NVIC 配置（标准库）

c

运行

```c
void TIM_Encoder_Config(void)
{
  // 1. 定时器基础配置（编码器模式，PSC=0，ARR=65535）
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_ICInitTypeDef TIM_ICInitStructure;
  
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
  
  TIM_TimeBaseStructure.TIM_Prescaler = 0; // 编码器模式PSC=0
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseStructure.TIM_Period = 65535; // ARR=65535
  TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
  TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
  
  // 2. 配置正交编码器模式（TI1/TI2双边沿计数）
  TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
  TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
  TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
  TIM_ICInitStructure.TIM_ICFilter = 0x00;
  TIM_ICInit(TIM3, &TIM_ICInitStructure);
  
  TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
  TIM_ICInit(TIM3, &TIM_ICInitStructure);
  
  TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
  TIM_Cmd(TIM3, ENABLE);
  
  // 3. 开启定时器更新中断
  TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
  
  // 4. NVIC配置（中断优先级，根据项目调整）
  NVIC_InitTypeDef NVIC_InitStructure;
  NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
}
```

#### 步骤 3：编写定时器中断服务函数（记录溢出次数）

c

运行

```c
void TIM3_IRQHandler(void)
{
  // 判断更新中断标志位
  if(TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
  {
    // 区分计数方向，更新溢出次数
    if(TIM_GetCounterMode(TIM3) == TIM_CounterMode_Up)
    {
      // 递增计数：计数器从65535归零，溢出次数+1
      encoder_overflow_cnt++;
    }
    else
    {
      // 递减计数：计数器从0归65535，下溢次数-1
      encoder_overflow_cnt--;
    }
    
    // 清除中断标志位（必须）
    TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
  }
}
```

#### 步骤 4：测速时进行溢出补偿（计算实际 ΔCNT）

在采样回调函数中，结合溢出次数和读取的计数值，计算真实增量：

c

运行

```c
volatile uint16_t last_cnt = 0;
volatile uint32_t real_delta_cnt = 0;

void Sample_Timer_Callback(void)
{
  uint16_t curr_cnt = TIM_GetCounter(TIM3);
  
  // 1. 计算原始增量
  int32_t raw_delta_cnt = curr_cnt - last_cnt;
  
  // 2. 溢出补偿：真实增量=原始增量 + 溢出次数×(ARR+1)
  real_delta_cnt = raw_delta_cnt + encoder_overflow_cnt × (65535 + 1);
  
  // 3. 重置溢出次数（为下一次采样做准备）
  encoder_overflow_cnt = 0;
  
  // 4. 更新上一次计数值
  last_cnt = curr_cnt;
  
  // 5. 后续：用real_delta_cnt计算电机转速（无误差）
}
```

#### 关键说明

- 补偿核心公式：`真实ΔCNT = 原始ΔCNT + 溢出次数×(ARR+1)`，其中`ARR+1`是计数器的一个完整计数周期（0~65535 共 65536 个值）；
- 每次采样后需重置`encoder_overflow_cnt`，避免多次采样溢出次数累积错误；
- 该方法可完全消除计数器溢出带来的测速误差，适合四驱小车高速行驶场景。

### 总结

1. PWM 最优参数：F103（PSC=3，ARR=599）、F407（PSC=3，ARR=999），编码器固定（PSC=0，ARR=65535）；
2. 预分频函数：定时器 PSC 用`TIM_TimeBaseInit()`/`TIM_PrescalerConfig()`，APB2 用`RCC_PCLK2Config()`；
3. 分辨率推荐 0.1%~0.5%，60 是单位换算系数，溢出补偿核心是记录中断次数并乘以计数周期；
4. 所有配置均围绕四驱小车的 “平稳调速” 和 “精准测速”，直接复用代码即可落地。